[{"id":0,"href":"/dive-into-go/basic/","title":"Basic","section":"","content":"  Package  Module  "},{"id":1,"href":"/dive-into-go/insides/compiler/","title":"Compiler","section":"Inside","content":"이번 장은 컴파일러에 대해 아주 조금 더 깊게 공부해보자. 일반적으로 실행 파일을 만드는 명령어로 빌드까지 완성하기 때문에, 컴파일러만의 역할을 평소에 경험하기 어렵다. 컴파일러를 통해 오브젝트 파일을 만드는 것과 기타 옵션들에 대해 다룬다.\n 프로그램이 프로세스가 되기까지 #  Go 컴파일러 #  컴파일러와 관련된 내용은 다음\nGo 코드를 컴파일 해서 오브젝트 파일을 만들기 위해서는 go tool compile을 사용한다. 컴파일을 하면, 마치 C언어 컴파일 한 것처럼 확장자가 o인 바이너리 오브젝트 파일을 내보낸다.\n$ go tool compile compiled.go   결과 ↕  $ ls -al drwxr-xr-x 4 changhoi staff 128 9 18 13:45 . drwxr-xr-x 3 changhoi staff 96 9 18 13:44 .. -rw-r--r-- 1 changhoi staff 73 9 18 13:45 compiled.go -rw-r--r-- 1 changhoi staff 7086 9 18 13:45 compiled.o $ file compiled.o compiled.o: current ar archive     결과물이 아카이브 파일이 나오는데, 여러 파일을 한 파일로 묶는 바이너리 파일이다.\n\u0026hellip; 공부하는 중\n"},{"id":2,"href":"/dive-into-go/insides/garbage-collection/","title":"Garbage Collection","section":"Inside","content":"Garbage Collection #  쓰레기 수집. 이때 쓰레기는 Heap영역에서 더 이상 사용하지 못하는 메모리를 의미하며, 이 부분들을 수집해 해제하는 역할을 Garbage Collection이라고 한다.\n 이하 Garbage Collection은 GC로 표현한다.\n GC는 일반적으로 다음 과정으로 동작한다.\n GC 수행하는 스레드를 제외하고 모두 Stop the world 참조할 수 없는 객체에 대한 메모리 해제 GC 종료 및 스레드 작업 재개  Tricolor 알고리즘 #  많은 언어에서 Tricolor 알고리즘을 사용해 가비지 컬렉팅을 한다. Go 언어에서 이 알고리즘 명칭은 Tricolor Mark-and-Sweep 알고리즘이다. Tricolor라는 뜻은, 삼색 이라는 뜻으로, 힙에 있는 오브젝트를 세 가지 색으로 나누기 때문에 붙은 이름이다. 검은색, 흰색, 회색으로 오브젝트를 구분하며, 다음과 같은 의미를 갖는다.\n 검은색: 흰색에 있는 오브젝트를 가리키는 포인터가 확실히 없는 오브젝트 흰색: 검은색 오브젝트를 가리킬 수도 있는 오브젝트 회색: 흰색 오브젝트 중 일부를 가리킬 수 있는 오브젝트  우선 가비지 컬렉터는 모든 오브젝트를 흰색으로 두고 시작한다. 각 색은 집합 안에 담겨서 관리된다. 그리고 다음 알고리즘을 따라 흰색을 추려나간다.\n 루트 오브젝트를 모두 회색 집합에 넣는다. 회색 집합의 오브젝트들을 검은색 오브젝트로 바꾸고, 흰색 오브젝트를 가리키고 있는 포인터가 있는지 확인한다. 흰색 오브젝트를 가리키는 포인터가 하나라도 있다면, 해당 흰색 오브젝트를 회색 집합에 넣는다. 2번과 3번 과정을 회색 집합에 아무 것도 남지 않을 때까지 반복한다. 흰색 오브젝트가 가비지 컬렉션된다.  루트 오브젝트\n스택에 있는 오브젝트, 또는 전역 변수와 같이 앱에서 직접 접근하는 오브젝트를 말한다.  이 작업이 진행되는 스레드를 뮤테이터(mutator) 스레드라고 한다. 뮤테이터는 힙에 있는 오브젝트의 포인터가 변경될 때마다 write barrier라는 함수를 실행한다. 오브젝트의 포인터가 변경되었다는 것은, 그 오브젝트에 접근이 가능하다는 것을 의미한다. 따라서 write barrier는 이 오브젝트를 회색 집합에 넣는다.  Mark and Sweep 알고리즘 #  기본적인 아이디어는, Stop the world 이후, 힙에 접근할 수 있는 오브젝트를 모두 검은색으로 바꾼다. 그 이후, 더 이상 확인해야 하는 회색 오브젝트가 없으면 Sweep 단계로 간다. Mark and Sweep 알고리즘은 GC를 구현한 알고리즘 중 간단하다는 장점이 있다. 그러나, Stop the world 방식이므로, 프로그램 실행을 중단해야 하는 문제가 있다.\n\u0026hellip; 작성 중\n"},{"id":3,"href":"/dive-into-go/insides/","title":"Inside","section":"","content":"이번 장은 Go 언어의 내부 동작에 집중된 이야기이다. 각 기능들의 내부 구조나 동작 과정을 정리했다.\n이번 장에서 다음 내용들을 학습할 수 있다.\n Go 컴파일러 Go 언어의 가비지 콜렉터 Go 언어의 스케줄러 Go build  시작하기  "},{"id":4,"href":"/dive-into-go/libraries/log/","title":"log","section":"Packages","content":"log 패키지는 로그 메시지를 유닉스 시스템 로그로 보내준다. 이번 장에서는 로그 수준과 종류를 설정해 로그를 시스템으로 보내는 방법을 정리하고 있다.\n Unix 시스템 로그 #  일반적으로 Unix 시스템의 로그 파일은 대부분 /var/log 디렉토리에 있다. 로깅 해야 하는 정보들을 커맨드라인에 표시하지 않고, 파일에 기록하는 것이 좋은데, 그 이유는 다음과 같다.\n 영구 지속 유닉스 도구의 지원을 받아 검색 및 처리 가능  로그 서버 #  유닉스 시스템에서는 로그 파일을 로깅하는 분리된 서버 프로세스가 존재한다. macOS의 경우 해당 프로세스 이름이 syslogd이다. 다른 대부분의 리눅스 시스템에서는 rsyslogd를 사용한다. syslogd보다 더 안정적이고 발전된 형태라고 한다.\n로그 수준 (Log Level) #  로그 내용의 응급도를 표현하는 값이다. debug, init, notice, warning, err, crit, alert, emerg 등이 있다. 쓰여진 순서대로 중요도가 높은 로그를 나타낸다.\n로그 종류 (Log Facilities) #  로그 종류는 로그가 포함되어있는 카테고리를 의미한다. auth, authpriv, cron, daemon, kern, lpr, mail, user, local0 ~ local7 등이 있다. 유닉스 서버에 /etc/rsyslog.conf 또는 /etc/rsyslog.d/*.conf 형태의 파일에서 종류들과 어떤 로그파일로 향하는지를 설정값으로 정해두었다.\nlog 패키지 #  Go에서 시스템 로그 파일에 메시지를 쓰는 방법을 확인해보자.\n// sysLog.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;log/syslog\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { process := \u0026#34;example\u0026#34; sysLog, e := syslog.New(syslog.LOG_NOTICE|syslog.LOG_MAIL, process) // 로그 레벨을 notice로, 로그 종류는 mail로 설정해서 syslog.Writer를 만들어준다.  // 두 번째 인자 값은, 로그 파일에서 필요한 정보를 얻기 위해 실행 중인 프로세스의 이름이 들어가는 것이 좋다.  if e != nil { log.Fatal(e) } sysLog.Crit(\u0026#34;Crit: Logging in Go!\u0026#34;) // 로그 레벨을 Writer에 지정하긴 했으나, 다른 우선 순위로 메시지를 보내는 것도 허용함  sysLog, e = syslog.New(syslog.LOG_ALERT|syslog.LOG_LOCAL7, \u0026#34;another \u0026#34; + process) // 같은 프로그램 내에서 sysLog Writer를 여러번 만들 수 있다. \tif e != nil { log.Fatal(sysLog) } sysLog.Emerg(\u0026#34;Emerg: Logging in Process!\u0026#34;) fmt.Fprintf(sysLog, \u0026#34;log.Print: Logging in Process!\u0026#34;) // Writer에 스트링을 씀으로써, New의 Writer에서 지정한 메시지 형식으로 로그 기록 } syslog.New 함수를 사용해 주어진 인자의 로그 레벨과 종류로 설정된 Writer 타입을 만들어낸다. 위 예시에서는 fmt.Fprintf를 사용해 스트링을 적었지만, log.SetOutput 함수를 사용해 기본 로거를 설정해준 뒤, log.Println을 사용해 로그 서버로 내용을 보내는 방법도 있다.\n... if e != nil { log.Fatal(e) } else { log.SetOutput(sysLog) } log.Println(\u0026#34;log.Print: Logging in Go!\u0026#34;) 결과는 브로드캐스팅 되기도 하고, 설정 파일에 지정된 파일들에 쌓이게 된다. 하나의 파일에 쌓일 수도 있지만 아닌 경우가 더 많다. 로그 레벨과 종류에 따라 여러 파일들에게 모두 중복해서 쓴다.\nlog.Fatal #  즉시 프로그램을 종료하고자 할 때 사용한다. 다만 종료시 설정된 로그 레벨과 로그 종류에 맞게 로그를 로그 서버에 보낸다.\n// fatal.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;log/syslog\u0026#34; ) func main() { sysLog, err := syslog.New(syslog.LOG_ALERT|syslog.LOG_MAIL, \u0026#34;process\u0026#34;) if err != nil { log.Fatal(err) } else { log.SetOutput(sysLog) } log.Fatal(\u0026#34;Fatal error on process\u0026#34;) // 이 메시지가 /var/log/mail.log에 찍혀있다. \tfmt.Println(\u0026#34;You can\u0026#39;t see me\u0026#34;) // 이 부분은 콘솔 위에서 확인할 수 없다. } log.Panic #  프로세스가 심각한 에러로 인해 죽는 상황에서, 관련한 정보를 최대한 볼 수 있는 방식이다. 호출 스택과 유관한 정보들을 포함해서 로그를 보여준다.\n// panic.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;log/syslog\u0026#34; ) func main() { sysLog, err := syslog.New(syslog.LOG_ALERT|syslog.LOG_MAIL, \u0026#34;process\u0026#34;) if err != nil { log.Fatal(err) } else { log.SetOutput(sysLog) } log.Panic(\u0026#34;fatal error on process\u0026#34;) fmt.Println(\u0026#34;You can\u0026#39;t see me\u0026#34;) //마찬가지로 볼 수가 없다. }  커스텀 로그 #  시스템에 설정된 로그 파일 외에 원하는 파일에 로그를 보내야 할 때가 있다. 예를 들어, 독립적인 로그 정보를 수집하려고 한다든지, 다른 포맷을 쓰고 싶다든지 등의 이유가 있다. 일반적인 파일 쓰기와 유사하지만, 로거를 만들어서 사용하는 부분에서 차이가 있다.\n// custom.go package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) const LOGFILE = \u0026#34;/tmp/custom.log\u0026#34; func main() { f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer f.Close() logger := log.New(f, \u0026#34;CUSTOM:\u0026#34;, log.LstdFlags) // New의 첫 번째 인자는 파일 Writer 타입, 두 번째는 접두사, 세 번째는 로그의 특성들을 추가해준다. \t// LstdFlags는 Local Date, Local Time이 있는 기본 로그 포맷이다.  logger.Println(\u0026#34;custom log\u0026#34;) }   결과 ↕  $ vi /tmp/custom.log CUSTOM:2021/09/18 00:56:43 custom log     파일 만들기에 대해서\nos.OpenFile은 첫 번째 인자로 파일 경로, 두 번째 인자로 파일 열기 모드를 설정하는 플래그, 마지막은 만약 생성한다면 적용되는 파일 권한이다.  log.New는 새로운 로거를 만들어준다. 첫 번째는 파일 쓰기 작업을 위한 io.Writer 타입이 필요하다. 두 번째는 로그 앞에 붙는 접두사를 설정하는 곳이고, 세 번째는 로그 파일의 특성(추가 정보) 속성이다. log.LstdFlags는 기본 로그의 로컬 타임과 로컬 데이트를 포함하는 플래그이다.\n 위와 같은 플래그들이 있는데, 여러 플래그를 합성하기 위해서는 log.LstdFlags | log.Lshortfile과 같이 비트 OR 연산자로 합성할 수 있다. 예시와 같이 합성하면, 파일 이름과 파일 줄 수를 로그 파일에 추가해준다.\n"},{"id":5,"href":"/dive-into-go/basic/module/","title":"Module","section":"Basic","content":"Go는 1.11부터 모듈에 지원을 시작했다. Module은 Go의 새로운 의존성 관리 시스템으로, 의존성의 버전 정보를 명확하고 관리하기 쉽게 만든다. 모듈은 파일 트리에 저장되는 Go 패키지 모음으로, 루트에 go.mod 파일이 있다. Go 1.11부터, 진행 중인 디렉토리가 GOPATH 변수의 src 아래가 아닌 경우, go 명령어는 현재 디렉토리나 또는 상위 디렉토리가 go.mod 파일을 가지고 있을 때 모듈을 사용하도록 했다. 그리고 1.13 이후 모든 개발 환경에서 기본 모드로 모듈을 사용했다.\n새로운 모듈 만들기 #  GOPATH가 아닌 곧에 새로운 디렉토리를 만들고 패키지를 만들자.\npackage hello func Hello() string { return \u0026#34;안녕, 세상.\u0026#34; } 위 상태에서 디렉토리 hello는 패키지를 담고 있지만, 모듈은 아니다. 왜냐면 go.mod 파일이 없기 때문이다. hello 디렉토리를 모듈의 루트로 만들기 위해서는 go mod init 명령어를 수행하면 된다. go mod init 명령어 인자로 패키지 이름이 들어가야 하는데, 일반적으로 패키지가 공유되는 URL 패스를 사용한다. example.com/hello 라는 이름으로 패키지를 만들었다.\n$ go mod init example.com/hello 경과로 go.mod 파일을 얻을 수 있는데 처음 만들어진 go.mod 파일은 다음과 같이 생겼다.\nmodule example.com/hello go 1.17 go.mod 파일은 모듈의 루트에만 나타난다. 하위 디렉토리의 패키지에는 루트 패키지 이름에서 하위 디렉토리 패스가 붙은 경로로 임포트할 수 있다. 예를 들어서 hello 패키지 아래 world 패키지가 있다면, hello/world 패키지로 자동적으로 인식된다.\n외부 모듈 사용하기 #  Go 모듈을 도입한 주된 이유는 다른 개발자들이 작성한 코드를 사용하는 경험을 개선하기 위해서이다. 방금 짠 hello.go에서 외부 패키지를 사용해보자.\npackage hello import \u0026#34;rsc.io/quote\u0026#34; func Hello() string { return quote.Hello() } go 명령은 go.mod에 나열된 특정 의존성 모듈의 버전을 사용해 임포트를 해결한다. 그런데, 임포트한 패키지가 go.mod 안의 어떠한 모듈에서도 제공하지 않는 패키지라면 go 명령어는 자동적으로 그 패키지를 담고 있는 모듈을 찾아서 go.mod에 최신버전으로 추가한다. 예시에서는 rsc.io/quote 패키지를 새로 다운로드하고, 그 패키지가 사용하는 두 개의 종속성 패키지를 추가로 가져왔다.\nmodule example.com/hello go 1.17 require rsc.io/quote v1.5.2 require ( golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c // indirect \trsc.io/sampler v1.3.0 // indirect ) \u0026hellip; 공부 더 하는 중\n"},{"id":6,"href":"/dive-into-go/basic/package/","title":"Package","section":"Basic","content":"Go는 크든 작든 패키지들로 구성된다. 패키지는 Go로 작성된 코드를 말하고, 코드 시작점에 package 키워드를 사용해 이름을 지정한다. 그 중 main 패키지는 독립적인 프로그램으로서 동작하는 소스 코드임을 알리는 패키지이고, 이외 다른 패키지는 실행 파일을 만들 수 없다. 즉, 실행을 위해서는 main 패키지의 메인 함수에서 호출되어야 한다. main 패키지는 다른 패키지가 공존하는 곳만 아니라면 어디에 짜든 상관 없다.\n프로그램을 짜다 보면, 어떤 시점에서는 결국 코드를 조직화 하고 분산시키기 위해 패키지를 만들어 사용해야 하는 시점이 있다. 패키지는 연관된 소스코드를 하나의 디렉토리 아래 둠으로써, 코드를 분산시킨다. 즉, 패키지는 소스 코드들로 구성되어있다.\n패키지 만들기 #  과거 Go는 패키지 임포트를 할 때, GOPATH에 설정된 작업 디렉토리의 src 디렉토리 아래나 GOROOT의 src에 패키지가 존재 했어야만 했다. 외부 모듈에 있는 패키지를 사용할 때에도 원래는 GOPATH/src 아래에 다운받아지는 방식이었지만, 현재는 모듈을 사용해 모듈과 유관한 패키지들을 버전과 함께 편하게 관리하고 있다.\ngo env GOPATH 명령어로 Go 환경 변수에 설정된 작업 디렉토리를 확인할 수 있다. 일반적으로 ~/go로 설정되어있다.  과거엔 버전 관리 방식이 아주 신기하게, Go 패키지들이 src 디렉토리에 모이면 그 전체 파일들을 하나의 stable 버전으로 관리하는 방식이라고 한다. 즉, 디테일한 버전 관리는 git을 통하게 하고, GOPATH 아래 모인 파일들이 하나의 모듈을 이룬다고 보는 것이다.  예를 들어, GOPATH/src에 아래와 같은 패키지가 선언되어 있다.\nbin/ pkg/ src/ diveintogo/ diveInto.go // diveintogo/diveInto.go package diveintogo import \u0026#34;fmt\u0026#34; func Book() { fmt.Println(\u0026#34;https://changhoi.github.io/dive-into-go\u0026#34;) } 패키지 이름은 되도록 소문자로 구성하는 것이 컨벤션이다.  현재 버전(1.17) 기준으로 이 패키지를 사용하려고 하면 GOROOT에 있는 것이 아니기 때문에 사용할 수 없다는 명령어를 보게 된다. 이는 패키지를 관리하는 방식이 기본적으로 모듈을 선택하도록 되어있기 때문인데, 과거 GOPATH를 사용하는 방식으로 바꾸면 정상 동작한다. Go는 패키지를 선택하는 방식을 관리하는 플래그를 Go 환경 변수에 담아 두었다. Go의 환경 변수에 있는 GO111MODULE이라는 환경 변수인데, on 상태인 경우 모듈 사용하는 방식으로 패키지를 가져오고, off 상태인 경우 GOPATH에서 패키지를 가져온다.\nGO111MODULE 환경 변수는 임시 환경 변수로, 버전이 높아지고 모듈을 사용하는 쪽으로 완전히 정착되고 나면 사라질 예정이라고 한다. 1.17 버전에 사라질 것이라는 말도 있었는데, 일단 현재도 보인다.  $ GO111MODULE=off go run main.go https://changhoi.github.io/dive-into-go main 패키지는 다른 패키지와 독립적인 곳이면 아무 공간에 두어도 된다.  위 방식은 1회 한정으로 환경 변수 값을 설정하는 방식이다. Go 모듈이 표준화 되고 있기 때문에, 기본값인 on으로 두고, 모듈을 사용하도록 하자. 모듈은 별도로 정리된 페이지가 있기 때문에, 자세한 내용은 생략하고, 패키지를 사용하기 위한 기본적인 방식을 보자.\n 다음 명령어로 현재 디렉토리를 하나의 모듈로서 정의한다.\ngo mod init [module name] 그러면, 이 디렉토리를 GOPATH/src와 같이 취급한다. 이 루트 디렉토리를 벗어나 다른 공간에서는 이 안에 있는 패키지를 인식할 수 없다.\n패키지를 구성하는 모듈로서 동작하게 하기 위해 위 명령어를 사용한 상태로 그 아래 패키지를 작성해야 한다.\nGo 모듈도 복잡한 역사와 구현 방식이 있기 때문에, 자세한 내용은 별도의 페이지에 정리했다.  패키지 구성 #  패키지는 일반적으로 디렉토리 기준으로 이름을 삼는다. 물론 같아야 하는 것은 아니다. 달라도 되지만, 임포트는 디렉토리 기준으로 임포트한다. 사용은 선언한 패키지 이름으로 사용한다. 다음과 같은 구성을 가진 모듈이 있다고 해보자.\noperation/ math.go go.mod main.go main.go는 math.go에서 두 수를 더하는 함수를 호출하고 있다. math.go는 operation이라는 이름의 디렉토리 아래 있지만, mathematics라는 이름의 패키지를 구성하고 있다.\n// main.go package main import ( \u0026#34;declare/operation\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(mathematics.Add(1, 1)) } // operation/math.go package mathematics func Add(a, b int) int { return a + b } 위 코드는 문제 없이 돌아간다. Go가 기본적으로는 패키지를 임포트 하는 방식이 디렉토리를 기준으로 하고 있음을 알 수 있다. 이를 통해 한 가지 더 알 수 있는 점은, 하나의 패키지 디렉토리 아래, 같은 Depth에서는 여러 패키지를 가질 수 없다는 것이다. 만약 operation/operation.go가 있어서, 그 파일에서는 package operation으로 선언하면, Go에서 declare/operation으로 임포트 했을 때, 어떤 패키지를 가져올지 알 수 없다. 따라서, 패키지 이름은 디렉토리에 종속적이지는 않지만, 임포트는 디렉토리 기준으로 하고, 사용할 때는 선언한 패키지 이름으로 사용한다는 것을 알 수 있다.\n디렉토리와 다른 이름으로 패키지를 만들었다면, 개발환경에 따라 앞에 alias가 붙기도 한다. import mathematics \u0026quot;declare/operation\u0026quot;와 같이 자동 완성 해준다. 가독성을 위해 웬만하면 같게 하는 것이 좋다.  init() 함수 #  각 패키지들은 선택적으로 init이라는 프라이빗 함수를 만들 수 있다. 이 함수는 패키지가 초기화 될 때 자동적으로 실행되는 함수이다. 다음과 같은 특징을 가지고 있다.\n 인자 값을 갖지 않고, 리턴 값도 없다. 메인 함수에서도 init 호출이 Go 내부적으로 발생한다. 그런 경우, main 함수보다 앞서서 호출된다. 실제로 모든 init 함수들은 main 함수보다 먼저 호출된다. 여러 개의 init 함수가 있을 수 있고, 이는 선언된 순서로 실행된다. init 함수는 프로세스의 라이프타임 중 일 회 호출되고 이후 얼마나 임포트 되는지와 무관하게 호출되지 않는다. 패키지는 여러 개의 파일을 담을 수 있다. 각 소스 파일은 하나 이상의 init 함수들을 가질 수 있다.  init 함수를 사용할만한 상황은, 패키지 함수들을 실행하기 전에 필요한 시간이 걸리는 작업을 미리 처리하는 상황이나, 존재해야 하는 파일을 미리 만들어둔다든지, 프로그램이 실행하기 위해 필요한 자원들이 모두 사용 가능한지 확인하는 등의 용도가 있다.\nmain 함수 실행을 위해 거쳐오는 길 #  다음과 같은 프로그램으로 확인해보자. test 라는 모듈을 만들어서, 그 아래 hello/hello.go, variable/variable.go, world/world.go를 만들어 각 디렉토리 이름으로 패키지를 만들었다. 아래와 같은 구조이다.\nhello/ hello.go greeting.go variable/ variable.go world/ world.go go.mod main.go 우선 각 패키지들은 모두 [구분자] + INIT이라는 문자열을 호출하는 init 함수가 있다. variable.go에서만 init 함수가 두 개 선언 되어있고, 각 init 함수는 마지막에 호출 순서에 따라 번호가 붙어있다. hello.go에서는 world.go에 있는 World 함수를 호출해서 Hello 함수를 구성하고 있다. greeting.go는 main.go에서 호출 중인 함수는 없지만, hello 패키지의 일부이고, 내부에 init 함수를 선언했다. main.go의 메인 함수에서는 hello.World 함수를 사용해 문자열을 출력한다. 그리고, 전역 변수들을 variable.go의 OverVar 함수와 UnderVar 함수를 이용해, 두 개를 초기화 하고 있다. 코드는 다음과 같다.\n// main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;test/hello\u0026#34; \u0026#34;test/variable\u0026#34; ) var overVar = variable.OverVar() func init() { fmt.Println(\u0026#34;MAIN INIT\u0026#34;) } func main() { fmt.Print(\u0026#34;MAIN FUNC / \u0026#34;) fmt.Println(hello.Hello()) } var underVar = variable.UnderVar() // hello/hello.go package hello import ( \u0026#34;fmt\u0026#34; \u0026#34;test/world\u0026#34; ) func init() { fmt.Println(\u0026#34;HELLO INIT\u0026#34;) } func Hello() string { return \u0026#34;Hello, \u0026#34; + world.World() } // hello/greeting.go package hello import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;GREETING INIT\u0026#34;) } // variable/variable.go package variable import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;VAR INIT1\u0026#34;) } func OverVar() string { fmt.Println(\u0026#34;OverVar Call\u0026#34;) return \u0026#34;OverVar\u0026#34; } func UnderVar() string { fmt.Println(\u0026#34;UnderVar Call\u0026#34;) return \u0026#34;UnderVar\u0026#34; } func init() { fmt.Println(\u0026#34;VAR INIT2\u0026#34;) } // world/world.go package world import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;WORLD INIT\u0026#34;) } func World() string { return \u0026#34;World!\u0026#34; } 이미지로 보자면 다음과 같이 의존 관계가 있다.\n 실행 결과는 다음과 같다.\n$ go run main.go WORLD INIT GREETING INIT HELLO INIT VAR INIT1 VAR INIT2 OverVar Call UnderVar Call MAIN INIT MAIN FUNC / Hello, World! 위 결과를 통해, 재귀적으로 같은 순서로 패키지를 실행하는 것을 알 수 있는데 그 순서는 다음과 같다.\n 패키지 도입 패키지에서 의존하는 패키지가 있다면, 해당 패키지 초기화 (Import된 순서대로, 다시 1번부터 재귀적으로 동작) 전역 변수 초기화 (선언된 순서대로) 패키지의 init 함수 호출 (선언된 순서대로)  위 과정으로 결과를 나눠보면, 다음과 같다.\n main 패키지 도입  hello 패키지 도입  world 패키지 도입  world.go의 init 함수 호출   greeting.go와 hello.go의 init 함수 호출 (알파벳 순)   variable 패키지 도입  variable.go의 init 함수 호출 (선언 순)     전역 변수 초기화 메인 함수 실행  "},{"id":7,"href":"/dive-into-go/libraries/","title":"Packages","section":"","content":"이번 장에서는, Go의 Standard Library를 활용 방법을 정리한다.\n다음 내용들을 학습한다.\n  log 패키지를 활용한 Unix 시스템 로그 활용 및 커스텀 로그 만들기  시작하기  "}]