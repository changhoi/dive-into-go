<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Basic on Dive into Go</title><link>https://changhoi.github.io/dive-into-go/basic/</link><description>Recent content in Basic on Dive into Go</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><atom:link href="https://changhoi.github.io/dive-into-go/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>Channel</title><link>https://changhoi.github.io/dive-into-go/basic/channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/basic/channel/</guid><description>Go는 동시성에 특화된 언어적 특성을 가지고 있다. 전통적인 방식의 언어에서는 그린 스레드(또는 OS 레벨의 스레드)를 만들고 공유 변수와 메모리 락을 통해 동시성을 제어하는 편이다. Go는 고루틴을 사용하고 이는 그린 스레드 개념보다 훨씬 가볍고 작다. 단순히 함수의 흐름(continuation이라고 표현한다)을 호스팅 하는 역할을 한다. 내부적으로 GOMAXPROCS 변수의 크기만큼 OS 레벨의 스레드를 만들고 그 수 만큼 논리 프로세서를 만들어 이 고루틴을 멀티플랙싱 하는 방식이다. 관련된 내용은 스케줄러 파트에서 자세히 다룬다. 어쨌든 Go는 이렇게 동시 실행되는(정확히는 순서를 알 수 없는) 고루틴을 동기화 하기 위해서 위에서 언급한 &amp;ldquo;전통적인 방식&amp;quot;을 제공하지만, 채널이라는 특수한 연결 고리 역시 제공하고 있다.</description></item><item><title>Module</title><link>https://changhoi.github.io/dive-into-go/basic/module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/basic/module/</guid><description>모듈은 Go가 의존성을 관리하는 방법이다. Go는 1.11부터 모듈에 지원을 시작했다. 모듈은 파일 트리에 저장되는 Go 패키지 모음으로, 루트에 go.mod 파일이 있다. Go 1.11부터, 진행 중인 디렉토리가 GOPATH 변수의 src 아래가 아닌 경우, go 명령어는 현재 디렉토리나 또는 상위 디렉토리가 go.mod 파일을 가지고 있을 때 모듈을 사용하도록 했다. 그리고 1.13 이후 모든 개발 환경에서 기본 모드로 모듈을 사용했다.
Go 모듈은 굉장히 자주 변경점이 생기고 있다. 공식 블로그에서 업데이트 되는 걸 주기적으로 확인해보자.</description></item><item><title>Package</title><link>https://changhoi.github.io/dive-into-go/basic/package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/basic/package/</guid><description>Go는 크든 작든 패키지들로 구성된다. 패키지는 Go로 작성된 코드를 말하고, 코드 시작점에 package 키워드를 사용해 이름을 지정한다. 그 중 main 패키지는 독립적인 프로그램으로서 동작하는 소스 코드임을 알리는 패키지이고, 이외 다른 패키지는 실행 파일을 만들 수 없다. 즉, 실행을 위해서는 main 패키지의 메인 함수에서 호출되어야 한다. main 패키지는 다른 패키지가 공존하는 곳만 아니라면 어디에 짜든 상관 없다.
프로그램을 짜다 보면, 어떤 시점에서는 결국 코드를 조직화 하고 분산시키기 위해 패키지를 만들어 사용해야 하는 시점이 있다.</description></item></channel></rss>