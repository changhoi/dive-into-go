[{"id":0,"href":"/dive-into-go/basic/","title":"Basic","section":"","content":"  Package  Module  "},{"id":1,"href":"/dive-into-go/libraries/context/","title":"context","section":"Packages","content":"context 패키지는 Go 개발을 하다 보면 심심치 않게 만날 수 있다. 패키지의 공식문서에 따르면, 이 패키지의 주된 목표는 데드라인, 취소 신호 및 기타 요청 범위 값을 API 경계와 프로세스들 사이에 전달하는 컨텍스트 유형을 만들기 위해 사용한다.\n Context 타입 #  Context 타입은 다섯 가지의 메소드를 가지고 있는 인터페이스이다. Deadline, Err, Value, Done이 있다.\ntype Context interface { Deadline() (deadline time.Time, ok bool) Done() \u0026lt;-chan struct{} Err() error Value(key interface{}) interface{} } Deadline #  컨텍스트를 대신해 수행된 작업을 취소해야 하는 시간을 반환한다. 데드라인은 설정되지 않으면 ok에 false담아 값을 반환한다.\nDone #  이 함수는 Context가 취소되었거나, 타임아웃이 발생하면 닫힌 수신용 채널을 리턴한다. 만약 이 Context가 취소될 수가 없는 것이라면, nil을 반환한다.\nErr #  Done이 아직 닫히지 않았다면, 이 함수는 nil을 반환한다. 만약 Done이 닫혀있다면, Err은 이유가 담긴 에러를 리턴한다. 만약 캔슬이 호출되었다면, Canceled 에러를 리턴하고, 데드라인이 지났다면, DeadlineExceeded 에러를 반환한다.\nValue #  해당 Context와 연관된 key에 대한 값을 리턴하거나, 어떠한 값도 이 키와 연관이 없는 경우 nil을 리턴한다.\nContext 타입을 사용해야 한다면, 직접 구현하기 보다는 WithCancel, WithDeadline, WithTimeout 같은 함수들을 사용해 만들 수 있다.\n WithCancel, WithDeadline, WithTimeout 함수들은 Context를 받아서 각 이름에 맞게 설정된 새로운 자식 Context와 CancelFunc 형태의 함수를 내보낸다. CallFunc은 호출되면 해당 컨텍스트와 그 자식들을 취소 시키고, 컨텍스트의 부모가 해당 컨텍스트를 참조하고 있던 레퍼런스를 삭제한다. 그리고 연관된 타이머들을 모두 정지시킨다. CallFunc를 호출하는 것에 실패하면 부모가 취소되기 전까지 메모리 릭이 발생하는 것과 같다.\n빈 Context 만들기 #  비어있는 Context라는 말은, 절대 취소되지도 않고, 값고 없고, 데드라인도 없는 Context라는 뜻이다. 이런 빈 Context는 다음 두 가지 함수로 만들 수 있다.\nBackground() #  빈 Context를 리턴한다. 일반적으로 메인 함수, 초기화, 테스트 과정 그리고 들어오는 요청들에 대한 루트 Context로 자주 사용된다.\nTODO() #  어떤 Context를 사용할지 모르겠거나, 명확하지 않다면 이 함수를 사용해 빈 Context를 만든다.\nWithCancel #  부모가 되는 Context를 인자로 받아 새로운 Done 채널과 함께 복사 한 값을 리턴한다. 반환된 Context의 Done 채널은 반환된 취소 함수가 호출되거나 부모의 Done 채널이 막히면 같이 막히게 된다.\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { ctx := context.Background() parent, parentCancel := context.WithCancel(ctx) child, childCancel := context.WithCancel(parent) if len(os.Args) != 3 { fmt.Printf(\u0026#34;usage: %s \u0026lt;parent delay\u0026gt; \u0026lt;child delay\u0026gt;\\n\u0026#34;, filepath.Base(os.Args[0])) os.Exit(1) } parentDelay, _ := strconv.Atoi(os.Args[1]) childDelay, _ := strconv.Atoi(os.Args[2]) go func() { time.Sleep(time.Duration(parentDelay) * time.Second) parentCancel() }() go func() { time.Sleep(time.Duration(childDelay) * time.Second) childCancel() }() select { case \u0026lt;-child.Done(): fmt.Println(\u0026#34;Child closed!:\u0026#34;, child.Err()) fmt.Println(\u0026#34;Parent not closed!:\u0026#34;, parent.Err()) case \u0026lt;-parent.Done(): fmt.Println(\u0026#34;Parent closed!:\u0026#34;, parent.Err()) fmt.Println(\u0026#34;Child closed!:\u0026#34;, child.Err()) } }   결과 ↕  $ go run withCancel.go 1 2 Parent closed!: context canceled Child closed!: context canceled $ go run withCancel.go 2 1 Child closed!: context canceled Parent not closed!: \u0026lt;nil\u0026gt;     위 예시에서처럼 부모가 닫히면 자동으로 자식의 Done 채널이 닫히면서 에러값을 갖게 되고, 반대는 성립하지 않는다.\n 취소하는 동작은 고루틴이 릭되는 현상을 막아줄 수 있다. 아래는 Go 패키지에서 제공되는 예시이다.\nimport ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { gen := func(ctx context.Context) \u0026lt;-chan int { dst := make(chan int) n := 1 go func() { for { select { case \u0026lt;-ctx.Done(): return // 고루틴이 릭되는 것을 막기 위해 리턴 \tcase dst \u0026lt;- n: n++ } } }() return dst } ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 정수를 하나씩 소비하는 것을 끝내면 고루틴 종료  for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } } }   결과 ↕  1 2 3 4 5     WithDeadline #  사실 Cancel에 대해 이해 했다면, 그 뒤는 비슷하다. 이 함수는 부모 Context에서 데드라인을 조정해서 내보낸다. 인자 값으로 들어오는 d 이후를 데드라인으로 설정한다. 만약 부모 Context의 데드라인이 설정되어있고, d보다 이르다면, 부모에게 맞춘다 (어짜피 부모가 취소 되면 자식되 취소 됨). 반환된 Context의 Done 채널은 데드라인이 지나거나, cancel 함수를 호출하면 닫히게 된다.\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) func main() { if len(os.Args) != 2 { fmt.Printf(\u0026#34;usage %s \u0026lt;deadline\u0026gt;\\n\u0026#34;, filepath.Base(os.Args[0])) os.Exit(1) } t, _ := strconv.Atoi(os.Args[1]) deadline := time.Now().Add(time.Duration(t) * time.Second) ctx := context.Background() ctx, cancel := context.WithDeadline(ctx, deadline) go func() { select { case \u0026lt;-time.After(time.Duration(3) * time.Second): fmt.Println(\u0026#34;TOO LONG DEADLINE!\u0026#34;) cancel() } }() select { case \u0026lt;-ctx.Done(): fmt.Println(\u0026#34;closed!:\u0026#34;, ctx.Err()) } }   결과 ↕  $ go run withDeadline.go 2 closed!: context deadline exceeded $ go run withDeadline.go 4 TOO LONG DEADLINE! closed!: context canceled     데드라인을 지나서 Done의 채널이 닫히면, DeadlineExceeded 에러를 보내고, cancel 함수를 사용해서 닫으면 Canceled 에러를 보낸다.\nWithTimeout #  이 함수는 데드라인 함수를 쉽게 쓰게 해준다. 인자로 들어온 Duration을 가지고 다음과 같이 리턴한다.\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) { return WithDeadline(parent, time.Now().Add(timeout)) } WithValue #  이 함수는 다른 함수들과 마찬가지로, 부모 Context를 사용하지만, 키와 값을 함께 넣어서 저장한다. Context에 특정 값을 저장해둘 수 있다. 이 값은 추가 인자값을 다른 함수에 전달하는 용도로 쓰지말라고 공식 문서에 설명되어있다.\n제공된 키는 반드시 비교가능해야 하고, 문자열이나 내장된 유형이면 안된다. 컨텍스트를 사용하는 패키지 사이에 충돌을 방지하기 위해서이다. WithValue를 사용하려면, 키 유형을 직접 정의해야한다.\n아래는 Go 패키지에 있는 예시이다.\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { type favContextKey string f := func(ctx context.Context, k favContextKey) { if v := ctx.Value(k); v != nil { fmt.Println(\u0026#34;found value:\u0026#34;, v) return } fmt.Println(\u0026#34;key not found:\u0026#34;, k) } k := favContextKey(\u0026#34;language\u0026#34;) ctx := context.WithValue(context.Background(), k, \u0026#34;Go\u0026#34;) f(ctx, k) f(ctx, favContextKey(\u0026#34;color\u0026#34;)) }   결과 ↕  found value: Go key not found: color      더 실용적인 예시들 #  Context는 언급한 대로 API의 사이 경계 부분이라든지, 고루틴의 릭되는 것을 막기 위해 Concurrency 패턴에서 자주 등장한다. 아래 블로그 글들을 보면, context 패키지의 실용적 예시들을 확인할 수 있다.\n  https://gobyexample.com/context  https://go.dev/blog/context  "},{"id":2,"href":"/dive-into-go/insides/garbage-collection/","title":"Garbage Collection","section":"Inside","content":"Garbage Collection #  쓰레기 수집. 이때 쓰레기는 Heap영역에서 더 이상 사용하지 못하는 메모리를 의미하며, 이 부분들을 수집해 해제하는 역할을 Garbage Collection이라고 한다.\n 이하 Garbage Collection은 GC로 표현한다.\n GC는 일반적으로 다음 과정으로 동작한다.\n GC 수행하는 스레드를 제외하고 모두 Stop the world 참조할 수 없는 객체에 대한 메모리 해제 GC 종료 및 스레드 작업 재개  Tricolor 알고리즘 #  많은 언어에서 Tricolor 알고리즘을 사용해 가비지 컬렉팅을 한다. Go 언어에서 이 알고리즘 명칭은 Tricolor Mark-and-Sweep 알고리즘이다. Tricolor라는 뜻은, 삼색 이라는 뜻으로, 힙에 있는 오브젝트를 세 가지 색으로 나누기 때문에 붙은 이름이다. 검은색, 흰색, 회색으로 오브젝트를 구분하며, 다음과 같은 의미를 갖는다.\n 검은색: 흰색에 있는 오브젝트를 가리키는 포인터가 확실히 없는 오브젝트 흰색: 검은색 오브젝트를 가리킬 수도 있는 오브젝트 회색: 흰색 오브젝트 중 일부를 가리킬 수 있는 오브젝트  우선 가비지 컬렉터는 모든 오브젝트를 흰색으로 두고 시작한다. 각 색은 집합 안에 담겨서 관리된다. 그리고 다음 알고리즘을 따라 흰색을 추려나간다.\n 루트 오브젝트를 모두 회색 집합에 넣는다. 회색 집합의 오브젝트들을 검은색 오브젝트로 바꾸고, 흰색 오브젝트를 가리키고 있는 포인터가 있는지 확인한다. 흰색 오브젝트를 가리키는 포인터가 하나라도 있다면, 해당 흰색 오브젝트를 회색 집합에 넣는다. 2번과 3번 과정을 회색 집합에 아무 것도 남지 않을 때까지 반복한다. 흰색 오브젝트가 가비지 컬렉션된다.  루트 오브젝트\n스택에 있는 오브젝트, 또는 전역 변수와 같이 앱에서 직접 접근하는 오브젝트를 말한다.  이 작업이 진행되는 스레드를 뮤테이터(mutator) 스레드라고 한다. 뮤테이터는 힙에 있는 오브젝트의 포인터가 변경될 때마다 write barrier라는 함수를 실행한다. 오브젝트의 포인터가 변경되었다는 것은, 그 오브젝트에 접근이 가능하다는 것을 의미한다. 따라서 write barrier는 이 오브젝트를 회색 집합에 넣는다.  Mark and Sweep 알고리즘 #  기본적인 아이디어는, Stop the world 이후, 힙에 접근할 수 있는 오브젝트를 모두 검은색으로 바꾼다. 그 이후, 더 이상 확인해야 하는 회색 오브젝트가 없으면 Sweep 단계로 간다. Mark and Sweep 알고리즘은 GC를 구현한 알고리즘 중 간단하다는 장점이 있다. 그러나, Stop the world 방식이므로, 프로그램 실행을 중단해야 하는 문제가 있다.\n\u0026hellip; 작성 중\n"},{"id":3,"href":"/dive-into-go/insides/","title":"Inside","section":"","content":"이번 장은 Go 언어의 내부 동작에 집중된 이야기이다. 각 기능들의 내부 구조나 동작 과정을 정리했다.\n이번 장에서 다음 내용들을 학습할 수 있다.\n Go 언어의 가비지 콜렉터 Go 언어의 스케줄러  "},{"id":4,"href":"/dive-into-go/libraries/log/","title":"log","section":"Packages","content":"log 패키지는 로그 메시지를 유닉스 시스템 로그로 보내준다. 이번 장에서는 로그 수준과 종류를 설정해 로그를 시스템으로 보내는 방법을 정리하고 있다.\n Unix 시스템 로그 #  일반적으로 Unix 시스템의 로그 파일은 대부분 /var/log 디렉토리에 있다. 로깅 해야 하는 정보들을 커맨드라인에 표시하지 않고, 파일에 기록하는 것이 좋은데, 그 이유는 다음과 같다.\n 영구 지속 유닉스 도구의 지원을 받아 검색 및 처리 가능  로그 서버 #  유닉스 시스템에서는 로그 파일을 로깅하는 분리된 서버 프로세스가 존재한다. macOS의 경우 해당 프로세스 이름이 syslogd이다. 다른 대부분의 리눅스 시스템에서는 rsyslogd를 사용한다. syslogd보다 더 안정적이고 발전된 형태라고 한다.\n로그 수준 (Log Level) #  로그 내용의 응급도를 표현하는 값이다. debug, init, notice, warning, err, crit, alert, emerg 등이 있다. 쓰여진 순서대로 중요도가 높은 로그를 나타낸다.\n로그 종류 (Log Facilities) #  로그 종류는 로그가 포함되어있는 카테고리를 의미한다. auth, authpriv, cron, daemon, kern, lpr, mail, user, local0 ~ local7 등이 있다. 유닉스 서버에 /etc/rsyslog.conf 또는 /etc/rsyslog.d/*.conf 형태의 파일에서 종류들과 어떤 로그파일로 향하는지를 설정값으로 정해두었다.\nlog 패키지 #  Go에서 시스템 로그 파일에 메시지를 쓰는 방법을 확인해보자.\n// sysLog.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;log/syslog\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { process := \u0026#34;example\u0026#34; sysLog, e := syslog.New(syslog.LOG_NOTICE|syslog.LOG_MAIL, process) // 로그 레벨을 notice로, 로그 종류는 mail로 설정해서 syslog.Writer를 만들어준다.  // 두 번째 인자 값은, 로그 파일에서 필요한 정보를 얻기 위해 실행 중인 프로세스의 이름이 들어가는 것이 좋다.  if e != nil { log.Fatal(e) } sysLog.Crit(\u0026#34;Crit: Logging in Go!\u0026#34;) // 로그 레벨을 Writer에 지정하긴 했으나, 다른 우선 순위로 메시지를 보내는 것도 허용함  sysLog, e = syslog.New(syslog.LOG_ALERT|syslog.LOG_LOCAL7, \u0026#34;another \u0026#34; + process) // 같은 프로그램 내에서 sysLog Writer를 여러번 만들 수 있다. \tif e != nil { log.Fatal(sysLog) } sysLog.Emerg(\u0026#34;Emerg: Logging in Process!\u0026#34;) fmt.Fprintf(sysLog, \u0026#34;log.Print: Logging in Process!\u0026#34;) // Writer에 스트링을 씀으로써, New의 Writer에서 지정한 메시지 형식으로 로그 기록 } syslog.New 함수를 사용해 주어진 인자의 로그 레벨과 종류로 설정된 Writer 타입을 만들어낸다. 위 예시에서는 fmt.Fprintf를 사용해 스트링을 적었지만, log.SetOutput 함수를 사용해 기본 로거를 설정해준 뒤, log.Println을 사용해 로그 서버로 내용을 보내는 방법도 있다.\n... if e != nil { log.Fatal(e) } else { log.SetOutput(sysLog) } log.Println(\u0026#34;log.Print: Logging in Go!\u0026#34;) 결과는 브로드캐스팅 되기도 하고, 설정 파일에 지정된 파일들에 쌓이게 된다. 하나의 파일에 쌓일 수도 있지만 아닌 경우가 더 많다. 로그 레벨과 종류에 따라 여러 파일들에게 모두 중복해서 쓴다.\nlog.Fatal #  즉시 프로그램을 종료하고자 할 때 사용한다. 다만 종료시 설정된 로그 레벨과 로그 종류에 맞게 로그를 로그 서버에 보낸다.\n// fatal.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;log/syslog\u0026#34; ) func main() { sysLog, err := syslog.New(syslog.LOG_ALERT|syslog.LOG_MAIL, \u0026#34;process\u0026#34;) if err != nil { log.Fatal(err) } else { log.SetOutput(sysLog) } log.Fatal(\u0026#34;Fatal error on process\u0026#34;) // 이 메시지가 /var/log/mail.log에 찍혀있다. \tfmt.Println(\u0026#34;You can\u0026#39;t see me\u0026#34;) // 이 부분은 콘솔 위에서 확인할 수 없다. } log.Panic #  프로세스가 심각한 에러로 인해 죽는 상황에서, 관련한 정보를 최대한 볼 수 있는 방식이다. 호출 스택과 유관한 정보들을 포함해서 로그를 보여준다.\n// panic.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;log/syslog\u0026#34; ) func main() { sysLog, err := syslog.New(syslog.LOG_ALERT|syslog.LOG_MAIL, \u0026#34;process\u0026#34;) if err != nil { log.Fatal(err) } else { log.SetOutput(sysLog) } log.Panic(\u0026#34;fatal error on process\u0026#34;) fmt.Println(\u0026#34;You can\u0026#39;t see me\u0026#34;) //마찬가지로 볼 수가 없다. }  커스텀 로그 #  시스템에 설정된 로그 파일 외에 원하는 파일에 로그를 보내야 할 때가 있다. 예를 들어, 독립적인 로그 정보를 수집하려고 한다든지, 다른 포맷을 쓰고 싶다든지 등의 이유가 있다. 일반적인 파일 쓰기와 유사하지만, 로거를 만들어서 사용하는 부분에서 차이가 있다.\n// custom.go package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) const LOGFILE = \u0026#34;/tmp/custom.log\u0026#34; func main() { f, err := os.OpenFile(LOGFILE, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer f.Close() logger := log.New(f, \u0026#34;CUSTOM:\u0026#34;, log.LstdFlags) // New의 첫 번째 인자는 파일 Writer 타입, 두 번째는 접두사, 세 번째는 로그의 특성들을 추가해준다. \t// LstdFlags는 Local Date, Local Time이 있는 기본 로그 포맷이다.  logger.Println(\u0026#34;custom log\u0026#34;) }   결과 ↕  $ vi /tmp/custom.log CUSTOM:2021/09/18 00:56:43 custom log     파일 만들기에 대해서\nos.OpenFile은 첫 번째 인자로 파일 경로, 두 번째 인자로 파일 열기 모드를 설정하는 플래그, 마지막은 만약 생성한다면 적용되는 파일 권한이다.  log.New는 새로운 로거를 만들어준다. 첫 번째는 파일 쓰기 작업을 위한 io.Writer 타입이 필요하다. 두 번째는 로그 앞에 붙는 접두사를 설정하는 곳이고, 세 번째는 로그 파일의 특성(추가 정보) 속성이다. log.LstdFlags는 기본 로그의 로컬 타임과 로컬 데이트를 포함하는 플래그이다.\n 위와 같은 플래그들이 있는데, 여러 플래그를 합성하기 위해서는 log.LstdFlags | log.Lshortfile과 같이 비트 OR 연산자로 합성할 수 있다. 예시와 같이 합성하면, 파일 이름과 파일 줄 수를 로그 파일에 추가해준다.\n"},{"id":5,"href":"/dive-into-go/basic/module/","title":"Module","section":"Basic","content":"모듈은 Go가 의존성을 관리하는 방법이다. Go는 1.11부터 모듈에 지원을 시작했다. 모듈은 파일 트리에 저장되는 Go 패키지 모음으로, 루트에 go.mod 파일이 있다. Go 1.11부터, 진행 중인 디렉토리가 GOPATH 변수의 src 아래가 아닌 경우, go 명령어는 현재 디렉토리나 또는 상위 디렉토리가 go.mod 파일을 가지고 있을 때 모듈을 사용하도록 했다. 그리고 1.13 이후 모든 개발 환경에서 기본 모드로 모듈을 사용했다.\nGo 모듈은 굉장히 자주 변경점이 생기고 있다. 공식 블로그에서 업데이트 되는 걸 주기적으로 확인해보자.  이하 내용에서 GOPATH/src나 GOPATH/pkg는 Go 환경 변수에 GOPATH로 지정된 경로 아래 있는 src 디렉토리와 pkg 디렉토리를 의미한다.  새로운 모듈 만들기 #  GOPATH가 아닌 곳에 새로운 디렉토리를 만들고 패키지를 만들자.\npackage diveIntoGo func URL() string { return \u0026#34;https://changhoi.github.io/dive-into-go\u0026#34; } 이 패키지를 모듈로 만들고, Github에 배포해서 다른 모듈에서도 사용할 수 있게 만들 수 있다. 우선, 모듈로 만들기 위해서 go mod init 명령어를 수행한다. go mod init [저장소]와 같이 일반적으로 사용하는데, 저장소 주소는 주소 형태여야 하는 것은 아니다. 그냥 모듈의 이름이라고 보면 된다. 그러나 다른 모듈에서 이를 다운로드 할 때 이 이름을 기준으로 다운로드 하기 때문에, 외부에 공개하기 위해서는 저장소 이름을 써야 한다.\n$ go mod init github.com/changhoi/example-module 경과로 go.mod 파일을 얻을 수 있는데 처음 만들어진 go.mod 파일은 다음과 같이 생겼다.\nmodule github.com/changhoi/example-module go 1.17 go.mod 파일은 모듈의 루트에만 나타난다. 하위 디렉토리의 패키지에는 루트 패키지 이름에서 하위 디렉토리 패스가 붙은 경로로 임포트할 수 있다. 예를 들어서 hello 패키지 아래 world 패키지가 있다면, hello/world 패키지로 자동적으로 인식된다.\n이렇게 만든 모듈에 태그를 붙여 커밋하고 저장소에 업로드한다.\n$ git add . $ git commit -m \u0026#34;v1.0.0\u0026#34; $ git tag v1.0.0 $ git push origin master $ git push origin v1.0.0 외부 모듈 사용하기 #  Go 모듈을 도입한 주된 이유는 다른 개발자들이 작성한 코드를 사용하는 경험을 개선하기 위해서이다. 방금 짠 모듈을 다른 모듈에서 사용해보자. 아무 곳에나 메인 함수를 만들고 go mod init 명령어로 모듈을 구성하고, 다음 코드를 쓴다. 모듈 이름은 임의로 설정해도 상관없다.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/changhoi/example-module/diveIntoGo\u0026#34; ) func main() { fmt.Println(diveIntoGo.URL()) } 이를 정상 동작 시키기 위해서는 go get github.com/changhoi/example-module을 해주어야 한다. 해당 명령어를 입력하면 go.mod에 변경이 생기고, go.sum이 생긴다. 그리고 GOPATH/pkg/github.com에도 changhoi/example-module@v1.0.0이라는 디렉토리와, 좀 전에 짰던 코드들이 다운로드 되어있는 것을 확인할 수 있다. 메인 함수를 실행해보면 정상적으로 url이 출력되는 것을 확인할 수 있다.\n 결괴 ↕  $ go run main.go https://changhoi.github.io/dive-into-go     패키지를 모듈에 연결하는 과정 #  만약 go 명령어가 (패키지 경로)package path를 사용해서 패키지를 불러오고 있다면, go 명령어는 어떤 모듈이 해당 패키지를 제공하고 있는지를 결정해야 한다. go 명령어는 빌드 목록(build list)에서 패키지의 접두사 부분을 모듈 경로(module path)로 가지고 있는 모듈을 찾는다. 예를 들어서, example.com/a/b라는 패키지가 사용되고 있고, example.com/a 모듈이 빌드 리스트에 있다면 go 명령어는 example.com/a/b 디렉토리에 b 패키지가 있는지를 확인한다. 하나 이상의 *.go 파일이 있어야 해당 디렉토리가 패키지로서 존재한다고 판단한다. 만약 단 하나의 모듈만 해당 패키지를 제공하고 있는 경우, 그 모듈이 사용되고, 두 개 이상의 모듈이 발견되면 에러를 내보낸다.\ngo 명령어가 새로운 모듈을 찾아야 하는 경우, 즉 필요한 모듈이 설치되지 않은 상태인 경우, GOPROXY 환경 변수를 확인한다. GOPROXY는 콤마(,)로 연결된 리스트인데, 프록시 주소나 키워드 (direct or off)로 구성되어있다. 1.17 버전 기준으로 기본 값은 아래와 같다.\n$ go env GOPROXY https://proxy.golang.org,direct 프록시 주소는 go 명령어가 HTTP 통신을 하는 웹서버의 주소인데, 이 서버에서 go.mod 파일과 모듈 압축 파일을 받아온다. Module proxy에 대한 자세한 내용은 이 링크에서 확인할 수 있다. direct 키워드는 go 명령어가 버전 컨트롤 시스템과 직접 커뮤니케이션 해야 한다는 것을 말한다. off 키워드는 프록시 주소들 외 커뮤니케이션을 직접 시도하지 않는다.\n build list: go build나 go list, go test와 같은 빌드 명령어에서 사용되는 모듈 버전들의 리스트   모든 GOPROXY의 엔트리에 따라서, go 명령어는 패키지를 제공할만한 모든 모듈 패스들에게 가장 최신 버전의 패키지를 요청한다. \u0026ldquo;패키지를 제공할만한 모든 모듈 패스\u0026quot;라는 뜻은, 예를 들어서 example.com/a/b라는 패키지를 찾고 있다면, example.com/a, example.com을 의미한다. 성공적으로 요청을 받은 모듈 패스들에 대해 go 명령어는 가장 길게 매칭된 경로의 모듈을 사용한다. 그러나 모듈은 찾았지만 찾고자 하는 패키지가 존재하지 않는다고 판단되면, 에러를 내보낸다. 만약 모듈조차 찾지 못 하면 GOPROXY 리스트의 다음 주소로 옮겨간다.\n예를 들어서, go 명령어가 golang.org/x/net/html이라는 패키지를 담은 모듈을 찾고 있고, GOPROXY가 https://corp.example.com,https://proxy.golang.org로 설정되어있다면, 다음 순서로 요청을 보낸다.\n To https://corp.example.com/ (병렬 요청):  Request for latest version of golang.org/x/net/html Request for latest version of golang.org/x/net Request for latest version of golang.org/x Request for latest version of golang.org   To https://proxy.golang.org/ (모든 https://corp.example.com/ 에서의 요청이 404이거나 410라면):  Request for latest version of golang.org/x/net/html Request for latest version of golang.org/x/net Request for latest version of golang.org/x Request for latest version of golang.org    이렇게 적절한 모듈을 찾게 되면, go 명령어는 require 키워드를 새로운 모듈 경로와 버전과 함께 메인 모듈의 go.mod에 추가한다. 이렇게 설정되면 미래에 같은 모듈은 항상 같은 버전의 패키지를 다운하게 된다. 만약, 연결된 패키지가 메인 모듈 안에 있는 패키지에서 임포트 되고 있지 않다면, 새로 만들어진 require 키워드 라인 마지막에 //indirect 주석이 붙게 된다.\ngo.mod #  하나의 모듈은 UTF-8로 인코딩 된 텍스트 파일에 정의된다. 이 파일의 이름은 go.mod이고, 모듈의 루트 디렉토리에 위치한다. go.mod는 라인 지향적인 정의를 하고 있다. 즉, 하나의 라인이 하나의 지시사항을 의미한다. 각 줄은 키워드와 인자값들로 이루어져있다.\nmodule example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 각 키워드들은 Go에서 임포트 하는 것처럼, 괄호를 사용해 인접한 블록을 하나의 블록으로 만들 수 있다.\nrequire ( example.com/new/thing/v2 v2.3.4 example.com/old/thing v1.2.3 ) 키워드는 다음과 같은 의미를 지닌다.\nmodule #  메인 모듈의 경로를 정의한다. go.mod 파일은 반드시 하나의 module 키워드가 있어야 한다.\nmodule golang.org/x/net go #  해당 모듈이 주어진 go 버전으로 작성되었음을 가리키는 키워드이다.\ngo 1.17 require #  모듈 의존성의 최소 요구되는 버전을 선언한다. go 명령어는 각 요구되는 모듈 버전에 대해, 다시 go.mod 파일을 로드해서 해당 파일이 필요한 의존성을 통합한다. 모든 요구 사항들이 로드되고 나면 MVS(Minimal Version Selelction) 알고리즘에 따라서 모듈을 선택하고 빌드 리스트를 만든다.\ngo 명령어는 요구되는 모듈을 직접적으로 메인 모듈에서 사용하지는 않는 경우, //indirect 주석을 붙인다.\nrequire golang.org/x/net v1.2.3 require ( golang.org/x/crypto v1.4.5 // indirect golang.org/x/text v1.6.7 ) exclude #  특정 모듈의 버전이 go 명령어에 의해 로드되는 것을 막는다. 이 키워드는 메인 모듈의 go.mod에만 적용되고 다른 모듈들에게는 무시된다.\nexclude golang.org/x/net v1.2.3 exclude ( golang.org/x/crypto v1.4.5 golang.org/x/text v1.6.7 ) replace #  특정 버전의 모듈의 내용을 다른 모듈의 버전으로 대체하거나, 로컬 디렉토리로 대체하게 한다. go 명령어가 의존성을 해결할 때 replacement path 자리를 사용하게 된다.\nreplace module-path [module-version] =\u0026gt; replacement-path [replacement-version] require example.com/othermodule v1.2.3 replace example.com/othermodule =\u0026gt; example.com/myfork/othermodule v1.2.3-fixed retract #  go.mod에 의해 정의된 특정 모듈의 하나의 버전이나 버전의 범위를 지정한다. 이 키워드는 하나의 버전이 임시로 퍼블리싱 되어있거나 심각한 문제가 특정 버전이 배포된 다음 발견된 상황에 아주 유용하다.\nretract version // rationale retract [version-low,version-high] // rationale retract v1.1.0 // Published accidentally. retract [v1.0.0,v1.0.5] // Build broken on some platforms. Module-aware 명령어들 #  Module-aware라는 것은 패키지를 찾는 방법 중 하나이다. 두 가지 모드가 있는데, 하나는 Module-aware 모드이고, 하나는 GOPATH 모드이다. Module-aware 모드에서는 go 명령어들이 go.mod를 사용해서 의존성을 찾는다. GOPATH 모드에서는 의존성을 벤더 디렉토리(vendor directories)와 GOPATH에서 찾는다.\n1.16 버전 이후로는 Module-aware이 기본 모드가 되었다. 더 낮은 버전에서는 조상 디렉토리나, 현재 디렉토리에 go.mod가 있어야 Module-aware 모드로 동작했다. 이 두 가지 방식은 Go 환경 변수 중에 GO111MODULE\t환경 변수에 의해 결정된다. 다음 세 가지 값 중 하나를 갖는다.\n off: go.mod 파일을 무시하고 GOPATH 모드를 사용한다. on이거나 세팅값이 없는 경우: Module-aware 모드로 동작한다. 심지어 go.mod 파일을 찾지 못했더라도 이 방법으로 동작한다. 즉, go.mod가 없으면 동작하지 않는 명령어들이 있다. auto: go.mod 파일이 있으면 Mode-aware 모드로 동작한다. 1.15 버전 이전에는 이것이 기본값이다. go mod의 하위 명령어들과 버전 쿼리 (version query)가 있는 go install 명령어의 경우는 go.mod가 없어도 Module-aware 모드로 동작한다.  Build 명령어들 #  \u0026hellip; 공부중\n https://golang.org/ref/mod#build-commands\n"},{"id":6,"href":"/dive-into-go/basic/package/","title":"Package","section":"Basic","content":"Go는 크든 작든 패키지들로 구성된다. 패키지는 Go로 작성된 코드를 말하고, 코드 시작점에 package 키워드를 사용해 이름을 지정한다. 그 중 main 패키지는 독립적인 프로그램으로서 동작하는 소스 코드임을 알리는 패키지이고, 이외 다른 패키지는 실행 파일을 만들 수 없다. 즉, 실행을 위해서는 main 패키지의 메인 함수에서 호출되어야 한다. main 패키지는 다른 패키지가 공존하는 곳만 아니라면 어디에 짜든 상관 없다.\n프로그램을 짜다 보면, 어떤 시점에서는 결국 코드를 조직화 하고 분산시키기 위해 패키지를 만들어 사용해야 하는 시점이 있다. 패키지는 연관된 소스코드를 하나의 디렉토리 아래 둠으로써, 코드를 분산시킨다. 즉, 패키지는 소스 코드들로 구성되어있다.\n패키지 만들기 #  과거 Go는 패키지 임포트를 할 때, GOPATH에 설정된 작업 디렉토리의 src 디렉토리 아래나 GOROOT의 src에 패키지가 존재 했어야만 했다. 외부 모듈에 있는 패키지를 사용할 때에도 원래는 GOPATH/src 아래에 다운받아지는 방식이었지만, 현재는 모듈을 사용해 모듈과 유관한 패키지들을 버전과 함께 편하게 관리하고 있다.\ngo env GOPATH 명령어로 Go 환경 변수에 설정된 작업 디렉토리를 확인할 수 있다. 일반적으로 ~/go로 설정되어있다.  과거엔 버전 관리 방식이 아주 신기하게, Go 패키지들이 src 디렉토리에 모이면 그 전체 파일들을 하나의 stable 버전으로 관리하는 방식이라고 한다. 즉, 디테일한 버전 관리는 git을 통하게 하고, GOPATH 아래 모인 파일들이 하나의 모듈을 이룬다고 보는 것이다.  예를 들어, GOPATH/src에 아래와 같은 패키지가 선언되어 있다.\nbin/ pkg/ src/ diveintogo/ diveInto.go // diveintogo/diveInto.go package diveintogo import \u0026#34;fmt\u0026#34; func Book() { fmt.Println(\u0026#34;https://changhoi.github.io/dive-into-go\u0026#34;) } 패키지 이름은 되도록 소문자로 구성하는 것이 컨벤션이다.  현재 버전(1.17) 기준으로 이 패키지를 사용하려고 하면 GOROOT에 있는 것이 아니기 때문에 사용할 수 없다는 명령어를 보게 된다. 이는 패키지를 관리하는 방식이 기본적으로 모듈을 선택하도록 되어있기 때문인데, 과거 GOPATH를 사용하는 방식으로 바꾸면 정상 동작한다. Go는 패키지를 선택하는 방식을 관리하는 플래그를 Go 환경 변수에 담아 두었다. Go의 환경 변수에 있는 GO111MODULE이라는 환경 변수인데, on 상태인 경우 모듈 사용하는 방식으로 패키지를 가져오고, off 상태인 경우 GOPATH에서 패키지를 가져온다.\nGO111MODULE 환경 변수는 임시 환경 변수로, 버전이 높아지고 모듈을 사용하는 쪽으로 완전히 정착되고 나면 사라질 예정이라고 한다. 1.17 버전에 사라질 것이라는 말도 있었는데, 일단 현재도 보인다.  $ GO111MODULE=off go run main.go https://changhoi.github.io/dive-into-go main 패키지는 다른 패키지와 독립적인 곳이면 아무 공간에 두어도 된다.  위 방식은 1회 한정으로 환경 변수 값을 설정하는 방식이다. Go 모듈이 표준화 되고 있기 때문에, 기본값인 on으로 두고, 모듈을 사용하도록 하자. 모듈은 별도로 정리된 페이지가 있기 때문에, 자세한 내용은 생략하고, 패키지를 사용하기 위한 기본적인 방식을 보자.\n 다음 명령어로 현재 디렉토리를 하나의 모듈로서 정의한다.\ngo mod init [module name] 그러면, 이 디렉토리를 GOPATH/src와 같이 취급한다. 이 루트 디렉토리를 벗어나 다른 공간에서는 이 안에 있는 패키지를 인식할 수 없다.\n패키지를 구성하는 모듈로서 동작하게 하기 위해 위 명령어를 사용한 상태로 그 아래 패키지를 작성해야 한다.\nGo 모듈도 복잡한 역사와 구현 방식이 있기 때문에, 자세한 내용은 별도의 페이지에 정리했다.  패키지 구성 #  패키지는 일반적으로 디렉토리 기준으로 이름을 삼는다. 물론 같아야 하는 것은 아니다. 달라도 되지만, 임포트는 디렉토리 기준으로 임포트한다. 사용은 선언한 패키지 이름으로 사용한다. 다음과 같은 구성을 가진 모듈이 있다고 해보자.\noperation/ math.go go.mod main.go main.go는 math.go에서 두 수를 더하는 함수를 호출하고 있다. math.go는 operation이라는 이름의 디렉토리 아래 있지만, mathematics라는 이름의 패키지를 구성하고 있다.\n// main.go package main import ( \u0026#34;declare/operation\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(mathematics.Add(1, 1)) } // operation/math.go package mathematics func Add(a, b int) int { return a + b } 위 코드는 문제 없이 돌아간다. Go가 기본적으로는 패키지를 임포트 하는 방식이 디렉토리를 기준으로 하고 있음을 알 수 있다. 이를 통해 한 가지 더 알 수 있는 점은, 하나의 패키지 디렉토리 아래, 같은 Depth에서는 여러 패키지를 가질 수 없다는 것이다. 만약 operation/operation.go가 있어서, 그 파일에서는 package operation으로 선언하면, Go에서 declare/operation으로 임포트 했을 때, 어떤 패키지를 가져올지 알 수 없다. 따라서, 패키지 이름은 디렉토리에 종속적이지는 않지만, 임포트는 디렉토리 기준으로 하고, 사용할 때는 선언한 패키지 이름으로 사용한다는 것을 알 수 있다.\n디렉토리와 다른 이름으로 패키지를 만들었다면, 개발환경에 따라 앞에 alias가 붙기도 한다. import mathematics \u0026quot;declare/operation\u0026quot;와 같이 자동 완성 해준다. 가독성을 위해 웬만하면 같게 하는 것이 좋다.  init() 함수 #  각 패키지들은 선택적으로 init이라는 프라이빗 함수를 만들 수 있다. 이 함수는 패키지가 초기화 될 때 자동적으로 실행되는 함수이다. 다음과 같은 특징을 가지고 있다.\n 인자 값을 갖지 않고, 리턴 값도 없다. 메인 함수에서도 init 호출이 Go 내부적으로 발생한다. 그런 경우, main 함수보다 앞서서 호출된다. 실제로 모든 init 함수들은 main 함수보다 먼저 호출된다. 여러 개의 init 함수가 있을 수 있고, 이는 선언된 순서로 실행된다. init 함수는 프로세스의 라이프타임 중 일 회 호출되고 이후 얼마나 임포트 되는지와 무관하게 호출되지 않는다. 패키지는 여러 개의 파일을 담을 수 있다. 각 소스 파일은 하나 이상의 init 함수들을 가질 수 있다.  init 함수를 사용할만한 상황은, 패키지 함수들을 실행하기 전에 필요한 시간이 걸리는 작업을 미리 처리하는 상황이나, 존재해야 하는 파일을 미리 만들어둔다든지, 프로그램이 실행하기 위해 필요한 자원들이 모두 사용 가능한지 확인하는 등의 용도가 있다.\nmain 함수 실행을 위해 거쳐오는 길 #  다음과 같은 프로그램으로 확인해보자. test 라는 모듈을 만들어서, 그 아래 hello/hello.go, variable/variable.go, world/world.go를 만들어 각 디렉토리 이름으로 패키지를 만들었다. 아래와 같은 구조이다.\nhello/ hello.go greeting.go variable/ variable.go world/ world.go go.mod main.go 우선 각 패키지들은 모두 [구분자] + INIT이라는 문자열을 호출하는 init 함수가 있다. variable.go에서만 init 함수가 두 개 선언 되어있고, 각 init 함수는 마지막에 호출 순서에 따라 번호가 붙어있다. hello.go에서는 world.go에 있는 World 함수를 호출해서 Hello 함수를 구성하고 있다. greeting.go는 main.go에서 호출 중인 함수는 없지만, hello 패키지의 일부이고, 내부에 init 함수를 선언했다. main.go의 메인 함수에서는 hello.World 함수를 사용해 문자열을 출력한다. 그리고, 전역 변수들을 variable.go의 OverVar 함수와 UnderVar 함수를 이용해, 두 개를 초기화 하고 있다. 코드는 다음과 같다.\n// main.go package main import ( \u0026#34;fmt\u0026#34; \u0026#34;test/hello\u0026#34; \u0026#34;test/variable\u0026#34; ) var overVar = variable.OverVar() func init() { fmt.Println(\u0026#34;MAIN INIT\u0026#34;) } func main() { fmt.Print(\u0026#34;MAIN FUNC / \u0026#34;) fmt.Println(hello.Hello()) } var underVar = variable.UnderVar() // hello/hello.go package hello import ( \u0026#34;fmt\u0026#34; \u0026#34;test/world\u0026#34; ) func init() { fmt.Println(\u0026#34;HELLO INIT\u0026#34;) } func Hello() string { return \u0026#34;Hello, \u0026#34; + world.World() } // hello/greeting.go package hello import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;GREETING INIT\u0026#34;) } // variable/variable.go package variable import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;VAR INIT1\u0026#34;) } func OverVar() string { fmt.Println(\u0026#34;OverVar Call\u0026#34;) return \u0026#34;OverVar\u0026#34; } func UnderVar() string { fmt.Println(\u0026#34;UnderVar Call\u0026#34;) return \u0026#34;UnderVar\u0026#34; } func init() { fmt.Println(\u0026#34;VAR INIT2\u0026#34;) } // world/world.go package world import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;WORLD INIT\u0026#34;) } func World() string { return \u0026#34;World!\u0026#34; } 이미지로 보자면 다음과 같이 의존 관계가 있다.\n 실행 결과는 다음과 같다.\n$ go run main.go WORLD INIT GREETING INIT HELLO INIT VAR INIT1 VAR INIT2 OverVar Call UnderVar Call MAIN INIT MAIN FUNC / Hello, World! 위 결과를 통해, 재귀적으로 같은 순서로 패키지를 실행하는 것을 알 수 있는데 그 순서는 다음과 같다.\n 패키지 도입 패키지에서 의존하는 패키지가 있다면, 해당 패키지 초기화 (Import된 순서대로, 다시 1번부터 재귀적으로 동작) 전역 변수 초기화 (선언된 순서대로) 패키지의 init 함수 호출 (선언된 순서대로)  위 과정으로 결과를 나눠보면, 다음과 같다.\n main 패키지 도입  hello 패키지 도입  world 패키지 도입  world.go의 init 함수 호출   greeting.go와 hello.go의 init 함수 호출 (알파벳 순)   variable 패키지 도입  variable.go의 init 함수 호출 (선언 순)     전역 변수 초기화 메인 함수 실행  "},{"id":7,"href":"/dive-into-go/libraries/","title":"Packages","section":"","content":"이번 장에서는, Go의 Standard Library를 활용 방법을 정리한다.\n다음 내용들을 학습한다.\n  log 패키지를 활용한 Unix 시스템 로그 활용 및 커스텀 로그 만들기  context 패키지에 대하여  시작하기  "}]