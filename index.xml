<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dive into Go</title><link>https://changhoi.github.io/dive-into-go/</link><description>Recent content on Dive into Go</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><atom:link href="https://changhoi.github.io/dive-into-go/index.xml" rel="self" type="application/rss+xml"/><item><title>Compiler</title><link>https://changhoi.github.io/dive-into-go/insides/compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/insides/compiler/</guid><description>이번 장은 컴파일러에 대해 아주 조금 더 깊게 공부해보자. 일반적으로 실행 파일을 만드는 명령어로 빌드까지 완성하기 때문에, 컴파일러만의 역할을 평소에 경험하기 어렵다. 컴파일러를 통해 오브젝트 파일을 만드는 것과 기타 옵션들에 대해 다룬다.
프로그램이 프로세스가 되기까지 # Go 컴파일러 # 컴파일러와 관련된 내용은 다음
Go 코드를 컴파일 해서 오브젝트 파일을 만들기 위해서는 go tool compile을 사용한다. 컴파일을 하면, 마치 C언어 컴파일 한 것처럼 확장자가 o인 바이너리 오브젝트 파일을 내보낸다.</description></item><item><title>Garbage Collection</title><link>https://changhoi.github.io/dive-into-go/insides/garbage-collection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/insides/garbage-collection/</guid><description>Garbage Collection # 쓰레기 수집. 이때 쓰레기는 Heap영역에서 더 이상 사용하지 못하는 메모리를 의미하며, 이 부분들을 수집해 해제하는 역할을 Garbage Collection이라고 한다.
이하 Garbage Collection은 GC로 표현한다.
GC는 일반적으로 다음 과정으로 동작한다.
GC 수행하는 스레드를 제외하고 모두 Stop the world 참조할 수 없는 객체에 대한 메모리 해제 GC 종료 및 스레드 작업 재개 Tricolor 알고리즘 # 많은 언어에서 Tricolor 알고리즘을 사용해 가비지 컬렉팅을 한다. Go 언어에서 이 알고리즘 명칭은 Tricolor Mark-and-Sweep 알고리즘이다.</description></item><item><title>log</title><link>https://changhoi.github.io/dive-into-go/libraries/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/libraries/log/</guid><description>log 패키지는 로그 메시지를 유닉스 시스템 로그로 보내준다. 이번 장에서는 로그 수준과 종류를 설정해 로그를 시스템으로 보내는 방법을 정리하고 있다.
Unix 시스템 로그 # 일반적으로 Unix 시스템의 로그 파일은 대부분 /var/log 디렉토리에 있다. 로깅 해야 하는 정보들을 커맨드라인에 표시하지 않고, 파일에 기록하는 것이 좋은데, 그 이유는 다음과 같다.
영구 지속 유닉스 도구의 지원을 받아 검색 및 처리 가능 로그 서버 # 유닉스 시스템에서는 로그 파일을 로깅하는 분리된 서버 프로세스가 존재한다.</description></item><item><title>Module</title><link>https://changhoi.github.io/dive-into-go/basic/module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/basic/module/</guid><description>Go는 1.11부터 모듈에 지원을 시작했다. Module은 Go의 새로운 의존성 관리 시스템으로, 의존성의 버전 정보를 명확하고 관리하기 쉽게 만든다. 모듈은 파일 트리에 저장되는 Go 패키지 모음으로, 루트에 go.mod 파일이 있다. Go 1.11부터, 진행 중인 디렉토리가 GOPATH 변수의 src 아래가 아닌 경우, go 명령어는 현재 디렉토리나 또는 상위 디렉토리가 go.mod 파일을 가지고 있을 때 모듈을 사용하도록 했다. 그리고 1.13 이후 모든 개발 환경에서 기본 모드로 모듈을 사용했다.
새로운 모듈 만들기 # GOPATH가 아닌 곧에 새로운 디렉토리를 만들고 패키지를 만들자.</description></item><item><title>Package</title><link>https://changhoi.github.io/dive-into-go/basic/package/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://changhoi.github.io/dive-into-go/basic/package/</guid><description>Go는 크든 작든 패키지들로 구성된다. 패키지는 Go로 작성된 코드를 말하고, 코드 시작점에 package 키워드를 사용해 이름을 지정한다. 그 중 main 패키지는 독립적인 프로그램으로서 동작하는 소스 코드임을 알리는 패키지이고, 이외 다른 패키지는 실행 파일을 만들 수 없다. 즉, 실행을 위해서는 main 패키지의 메인 함수에서 호출되어야 한다. main 패키지는 다른 패키지가 공존하는 곳만 아니라면 어디에 짜든 상관 없다.
프로그램을 짜다 보면, 어떤 시점에서는 결국 코드를 조직화 하고 분산시키기 위해 패키지를 만들어 사용해야 하는 시점이 있다.</description></item></channel></rss>